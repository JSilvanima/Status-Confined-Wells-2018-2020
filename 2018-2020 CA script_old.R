# File: 2018-get2020 CA Script.R
# Purpose: Analysis of Florida Confined Aquifer data generated by the Status 
#  Monitoring Program. Created by Jay Silvanima using code developed 
#  by Tony Olsen, myself, Chris Sedlacek, Stephanie Sunderman-Barnes, 
#  and Liz Miller on 12-03-2020.
# Code developed using R version 3.6.2 (2019-12-12) and spsurvey version
#   4.1.0.

##Set directory. This is where the outputs will be saved. 
#   Alter to desired location. Use getwd() to determine the directory for
#     your r project.

setwd("C:/R/Status combined 2018-2020/2018-2020 CA")

# First pull data via use of package 'FDEPgetdata'. 

# Load libraries for the data analyses

library(FDEPgetdata)
library(spsurvey)
library(sf)
library(ggplot2)

# Run function of FDEPgetdata package which pull exclusion data.
#
# Insert varible names between parentheses in function call below. The
#  function will pull the site information for the water resource by year. 
# Entering 'well_listframe_2020',"'CA18','CA19','CA20'" for variables will 
#  3 data frames: 1) A data frame (Exclusions) containing all well evaluations 
#  for the three year period. 2) A data frame (well_removals) containing all 
#  wells evaluated in the three period which are no longer included in the 
#  traget population. 3) A data frame (SiteEvaluations) containing the wells 
#  which were evaluated and present in the well list frame for the most recent 
#  year evaluated.
#
# Be sure to enclose first variable in single quotes and second variable in 
#  double quotes.
#
# Water resource acronyms are CA = Confined Aquifers, UA = Unconfined Aquifers.

FDEPgetdata::getdata_aq_exclusions_3yr('well_listframe_2020',"'CA18','CA19','CA20'")

# Next need determine if any of the wells are no longer included in the traget 
#  population. Run below script which compares the primary key for the most 
#  recent well list frame to those found in the data pull for the three year period.

View(well_removals)

# Need to remove the 55 wells which are not found in the 2020 list frame.

list(well_removals$PK_RANDOM_SAMPLE_LOCATION)

SiteEvaluations <- Exclusions[!(Exclusions$PK_RANDOM_SAMPLE_LOCATION %in%
                                  
c('Z1-CA-12006', 'Z1-CA-12034', 'Z1-CA-12038','Z1-CA-12068', 'Z1-CA-13001', 'Z1-CA-13015',
'Z1-CA-13037', 'Z1-CA-13047', 'Z1-CA-13050', 'Z2-CA-12002', 'Z2-CA-12004', 'Z2-CA-12005',
'Z2-CA-12006', 'Z2-CA-12014', 'Z2-CA-12018', 'Z2-CA-12030', 'Z2-CA-12031', 'Z2-CA-12041',
'Z2-CA-12046', 'Z2-CA-12047', 'Z2-CA-12051', 'Z2-CA-13010', 'Z2-CA-13012', 'Z2-CA-13022',
'Z2-CA-13030', 'Z2-CA-13033', 'Z2-CA-13043', 'Z2-CA-13047', 'Z3-CA-12001', 'Z3-CA-12002',
'Z3-CA-12005', 'Z3-CA-12011', 'Z3-CA-12014', 'Z3-CA-12021', 'Z3-CA-12032', 'Z3-CA-13001',
'Z3-CA-13010', 'Z3-CA-13015', 'Z3-CA-13026', 'Z3-CA-13036', 'Z4-CA-12017', 'Z4-CA-12033',
'Z4-CA-12037', 'Z4-CA-12040', 'Z4-CA-12041', 'Z4-CA-13012', 'Z4-CA-13033', 'Z4-CA-13036',
'Z4-CA-13038', 'Z5-CA-12010', 'Z5-CA-12016', 'Z6-CA-12001', 'Z6-CA-12020', 'Z6-CA-13001',
'Z6-CA-13003')), ]

# A simpler way to do the same as the above by using the sqldf function

SiteEvaluations <- sqldf('select * from Exclusions 
          where PK_RANDOM_SAMPLE_LOCATION
                         not in (select PK_RANDOM_SAMPLE_LOCATION
                          from well_removals)')
  
View(SiteEvaluations)



# Create new data frame from the one just created.

CA.SITES<-SiteEvaluations
names(CA.SITES)

# Convert to Decimal degrees and do map projection

deg <- floor(CA.SITES$RANDOM_LATITUDE/10000)
min <- floor((CA.SITES$RANDOM_LATITUDE - deg*10000)/100)
sec <- CA.SITES$RANDOM_LATITUDE - deg*10000 - min*100
CA.SITES$latdd <- deg + min/60 + sec/3600
deg <- floor(CA.SITES$RANDOM_LONGITUDE/10000)
min <- floor((CA.SITES$RANDOM_LONGITUDE - deg*10000)/100)
sec <- CA.SITES$RANDOM_LONGITUDE - deg*10000 - min*100
CA.SITES$londd <- deg + min/60 + sec/3600

# Change londd to negative for correct use in sf.
CA.SITES$londd <- -CA.SITES$londd

# Create sf object and transform to Albers projection for analysis
#  This codes utilizes Coordinate Reference System (CRS/EPSG) Codes.
#  The first crs code (4269) below is for NAD 83 coordinate system the 
#  second crs code (3087) is for Florida albers projection. 
#  More information on these codes is found here: 
#  https://www.nceas.ucsb.edu/sites/default/files/2020-04/OverviewCoordinateReferenceSystems.pdf.

dsgn_aq <- st_as_sf(CA.SITES, coords = c("londd", "latdd"), remove = FALSE,
                    crs = 4269)
dsgn_sf <- st_transform(dsgn_aq, crs = 3087)

# keep xy coords as variables
tmp <- st_coordinates(dsgn_sf)
dsgn_sf$xcoord <- tmp[, "X"]
dsgn_sf$ycoord <- tmp[, "Y"]

# plot sites using sf
plot(st_geometry(dsgn_sf))


# Site Evaluation
#  The variables CAN_BE_SAMPLED, EXCLUSION_CATEGORY and EXCLUSION_CRITERIA 
#   provide information on the site evaluation results for each site. 
#  Review the information and create target/nontarget (TNT) variable.

addmargins(table(dsgn_sf$EXCLUSION_CATEGORY, dsgn_sf$CAN_BE_SAMPLED, useNA = 'ifany'))
addmargins(table(dsgn_sf$EXCLUSION_CRITERIA, useNA = 'ifany'))


# create sampled and target (T) / nontarget (NT) variables

dsgn_sf$EXCLUSION_CATEGORY <- as.character(dsgn_sf$EXCLUSION_CATEGORY)
dsgn_sf$EXCLUSION_CATEGORY[dsgn_sf$CAN_BE_SAMPLED == 'Y'] <- 'SAMPLED'
dsgn_sf$EXCLUSION_CATEGORY <- as.factor(dsgn_sf$EXCLUSION_CATEGORY)
levels(dsgn_sf$EXCLUSION_CATEGORY)
dsgn_sf$TNT <- dsgn_sf$EXCLUSION_CATEGORY
levels(dsgn_sf$TNT) <- list(T=c('SAMPLED', 'NO PERMISSION FROM OWNER', 'UNABLE TO ACCESS','OTHERWISE UNSAMPLEABLE','DRY'),
                            NT=c('WRONG RESOURCE/NOT PART OF TARGET POPULATION') )

addmargins(table(dsgn_sf$EXCLUSION_CATEGORY, dsgn_sf$TNT, useNA = 'ifany'))


# Note need frame size here found in design doc for confined aquifer site selections
#  Z:\Chris site selection process\2020 site selections\2020 wells\FL GW Wells 2020.doc
#  From design document framesize # confined wells = 15,339 for entire data frame.


framesize <- c("ZONE 1"=10349,"ZONE 2"=2706,"ZONE 3"=1163,"ZONE 4"=889,
               "ZONE 5"=207,"ZONE 6"=25)

# use all evaluated sites to adjust weights
nr <- nrow(dsgn_sf)
dsgn_sf$wgt <- adjwgt(rep(TRUE,nr), dsgn_sf$WELL_WEIGHT, 
                      dsgn_sf$REPORTING_UNIT, framesize=framesize)

# check sum of weights for each reporting unit/basin
addmargins(tapply(dsgn_sf$wgt, dsgn_sf$REPORTING_UNIT, sum))


# This gives the weights for the confined aquifer design as implememented 
#  in 2020. It must include all evaluated sites as some sites are not in the 
#  target population.


# Since the sample frame includes wells that do not meet the definition of a 
#  confined wells, the site evaluation information is used to estimate 
#  the number of wells in the target population for the entire state and 
#  for each of the reporting units/basins.

# Code for estimate of # wells in target population and of # wells which can be sampled.

sites <- data.frame(siteID = dsgn_sf$PK_RANDOM_SAMPLE_LOCATION, Use=rep(TRUE,nr) )
subpop <- data.frame(siteID = dsgn_sf$PK_RANDOM_SAMPLE_LOCATION,
                     Combined = rep("All Basins", nr), 
                     Basin = dsgn_sf$REPORTING_UNIT) 
dsgn <- data.frame(siteID = dsgn_sf$PK_RANDOM_SAMPLE_LOCATION, 
                   wgt = dsgn_sf$wgt,
                   xcoord = dsgn_sf$xcoord,
                   ycoord = dsgn_sf$ycoord,
                   stratum = dsgn_sf$REPORTING_UNIT)

data.cat <- data.frame(siteID = dsgn_sf$PK_RANDOM_SAMPLE_LOCATION,
                       TNTStatus=dsgn_sf$TNT,
                       EXCLUSION.CATEGORY = dsgn_sf$EXCLUSION_CATEGORY)

ExtentEst <- cat.analysis(sites, subpop, dsgn, data.cat, conf=95)

# write out or export results
write.csv(ExtentEst,file = 'CA2020_ExtentEst.csv')


# Of the 15,339 confined wells in the sample frame, 97.7% are estimated 
#  to be in the target population, i.e., 14,984 wells. Also, only 24.7% 
#  of the sample frame could actually be sampled. 

# To estimate the percent of the target population that could be sampled, 
#  requires that the analysis be stricted to just sites in the target 
#  population, i.e., TNT = "T"

sites <- data.frame(siteID = dsgn_sf$PK_RANDOM_SAMPLE_LOCATION, Use = dsgn_sf$TNT == "T" )
subpop <- data.frame(siteID = dsgn_sf$PK_RANDOM_SAMPLE_LOCATION,
                     Combined = rep("All Basins", nr), 
                     Basin = dsgn_sf$REPORTING_UNIT) 
dsgn <- data.frame(siteID = dsgn_sf$PK_RANDOM_SAMPLE_LOCATION, 
                   wgt = dsgn_sf$wgt,
                   xcoord = dsgn_sf$xcoord,
                   ycoord = dsgn_sf$ycoord,
                   stratum = dsgn_sf$REPORTING_UNIT)

data.cat <- data.frame(siteID = dsgn_sf$PK_RANDOM_SAMPLE_LOCATION,  
                       EXCLUSION.CATEGORY = dsgn_sf$EXCLUSION_CATEGORY)

ExtentEst_Target <- cat.analysis(sites, subpop, dsgn, data.cat, conf=95)

# write out or export results
write.csv(ExtentEst_Target, file = 'CA2020_ExtentEst_Target.csv')

# 25.3 % of the target population of wells could be sampled, i.e., 
#  3788 wells CI(2863 - 4712) wells.


#########################################################################################
#########################################################################################
# Water Quality Data

# Run function of FDEPgetdata package to pull result data. 
#
# Insert varible name between parentheses in function call below. The
#  function will pull the water resource for the water resource by year. 
#  For example confined aquifer projects during year 2020 the enty would 
#  be "'CA20'". Entering "'CA18','CA19','CA20'" for variable will produce a 
#  dataframe for FDEP Status confined aquifers sampled 2018 - 2020.
#  Be sure to enclose in double and single quotes.
#
# Water resource acronyms are CA = Confined Aquifers, UA = Unconfined Aquifers

FDEPgetdata::getdata_results("'CA20'")

# Function getdata_results creates the data frame 'Results'.

# Examine the Results data frame.  If more than two columns are present for 
#  each parameter, the data set includes samples with multiple results for at 
#  least one parameter.  Need to locate the affected samples and investigate 
#  further.  Type c(" in the R Studio search bar to search the results data 
#  frame for the affected samples.

# Create new data frame from the one just created.
CA_RSLTS<-Results
names(CA_RSLTS)

# Determine sample types in file.
addmargins(table(CA_RSLTS$SAMPLE_TYPE, CA_RSLTS$MATRIX, useNA = 'ifany'))

# Note that we have BLANK and PRIMARY data and matrix types. A total of 120 
#  wells sampled for water quality. Z4-CA-14009B and Z5-CA-14004B 
#  were inappropriately sampled and were listed as excluded after the their
#  data were analyzed. 

# Water Quality Analyses
# Water quality analyses are based on 118 sites from the results file and must be merged with design information.

keep <- CA_RSLTS$SAMPLE_TYPE == 'PRIMARY' & CA_RSLTS$MATRIX == 'WATER'

# merge with exclusion file
CA_WQ <- merge(as.data.frame(dsgn_sf)[, c("PK_RANDOM_SAMPLE_LOCATION",
                                          "REPORTING_UNIT", "EXCLUSION_CATEGORY","TNT", "wgt", 
                                          "londd", "latdd", "xcoord", "ycoord")], CA_RSLTS[keep,], 
               by.x = 'PK_RANDOM_SAMPLE_LOCATION', 
               by.y = 'FK_RANDOM_SAMPLE_LOCATION')

# check that have only PRIMARY for Water MATRIX data
addmargins(table(CA_WQ$SAMPLE_TYPE, CA_WQ$MATRIX, useNA = 'ifany'))


#####  Set up threshold category columns for cat.analysis

#### arsenic category
Arsenic_cat <- cut(CA_WQ$Arsenic_Total, breaks=c(0,10,100000), include.lowest=TRUE)
CA_WQ$Arsenic_cat <- Arsenic_cat
CA_WQ$Arsenic_cat <- as.factor(CA_WQ$Arsenic_cat)

#### cadmium category
Cadmium_cat <- cut(CA_WQ$Cadmium_Total, breaks=c(0,5,1000000), include.lowest=TRUE)
CA_WQ$Cadmium_cat <- Cadmium_cat
CA_WQ$Cadmium_cat <- as.factor(CA_WQ$Cadmium_cat)

### chromium category
Chromium_cat <- cut(CA_WQ$Chromium_Total, breaks=c(0,100,1000000), include.lowest=TRUE)
CA_WQ$Chromium_cat <- Chromium_cat
CA_WQ$Chromium_cat <- as.factor(CA_WQ$Chromium_cat)

### fluoride category
Fluoride_cat <- cut(CA_WQ$Fluoride_Total, breaks=c(0,4,1000000), include.lowest=TRUE)
CA_WQ$Fluoride_cat <- Fluoride_cat
CA_WQ$Fluoride_cat <- as.factor(CA_WQ$Fluoride_cat)

### lead category
Lead_cat <- cut(CA_WQ$Lead_Total, breaks=c(0,15,10000000), include.lowest=TRUE)
CA_WQ$Lead_cat <- Lead_cat
CA_WQ$Lead_cat <- as.factor(CA_WQ$Lead_cat)

### NitrateNitrite category
NitrateNitrite_cat <- cut(CA_WQ$NitrateNitrite_Total_as_N, breaks=c(0,10,1000000), include.lowest=TRUE)
CA_WQ$NitrateNitrite_cat <- NitrateNitrite_cat
CA_WQ$NitrateNitrite_cat <- as.factor(CA_WQ$NitrateNitrite_cat)

### sodium category
Sodium_cat <- cut(CA_WQ$Sodium_Total, breaks=c(0,160,1000000), include.lowest=TRUE)
CA_WQ$Sodium_cat <- Sodium_cat
CA_WQ$Sodium_cat <- as.factor(CA_WQ$Sodium_cat)

### Data preparation for coliform analyses
# Replace pass/fail category with '1' for values meeting the 
#  coliform criteria (< 2 counts for fecal, <= 4 counts for total)
#  and with '0' for those not meeting the criteria.
# Note code also replaces pass/fail category values with '1' for those coliform 
#  measurements which have reported values above the criteria and are 
#  listed as below detection ('U' qualifier).

### total coliform categories
CA_WQ$TC_cat<-ifelse((CA_WQ$Coliform_Total_MF <= 4 |
              grepl('U', CA_WQ$Coliform_Total_MF_VQ, fixed=TRUE)),1,0) 

### fecal coliform categories
CA_WQ$FC_cat<-ifelse((CA_WQ$Coliform_Fecal_MF < 2 |
              grepl('U', CA_WQ$Coliform_Fecal_MF_VQ, fixed=TRUE)),1,0)  

##########################################################################
# Continuous and categorical water quality indicator population estimation

nr <- nrow(CA_WQ)
levels(CA_WQ$TNT)

sites_WQ <- data.frame(siteID = CA_WQ$PK_RANDOM_SAMPLE_LOCATION, Use = CA_WQ$TNT == "T" )
subpop_WQ <- data.frame(siteID = CA_WQ$PK_RANDOM_SAMPLE_LOCATION,
                        Combined = rep("All Basins", nrow(CA_WQ)), 
                        Basin = CA_WQ$REPORTING_UNIT) 
dsgn_WQ <- data.frame(siteID = CA_WQ$PK_RANDOM_SAMPLE_LOCATION, 
                      wgt = CA_WQ$wgt,
                      xcoord = CA_WQ$xcoord,
                      ycoord = CA_WQ$ycoord,
                      stratum = CA_WQ$REPORTING_UNIT)

# continuous WQ estimates

data.cont.WQ <- data.frame(siteID=CA_WQ$PK_RANDOM_SAMPLE_LOCATION, 
                           CA_WQ[,c('Water_Temperature','pH_Field','Specific_Conductance_Field',
                                    'Kjeldahl_Nitrogen_Total_as_N','NitrateNitrite_Total_as_N',
                                    'Phosphorus_Total_as_P','Fluoride_Total','Chloride_Total',
                                    'Sodium_Total','Total_Dissolved_Solids_TDS_measured',
                                    'Hardness_calculated_as_CACO3','Alkalinity_Total_as_CaCO3',
                                    'Coliform_Fecal_MF','Coliform_Total_MF','Cadmium_Total',
                                    'Chromium_Total','Lead_Total','Arsenic_Total')])


Water_quality_Cont <- cont.analysis(sites = sites_WQ, subpop = subpop_WQ, 
                                    design = dsgn_WQ, data.cont = data.cont.WQ, conf=95)

# categorical WQ estimates

data.cat.wq <- data.frame(siteID = CA_WQ$PK_RANDOM_SAMPLE_LOCATION,
                          Arsenic_Category = CA_WQ$Arsenic_cat,
                          Cadmium_Category = CA_WQ$Cadmium_cat,
                          Chromium_Category = CA_WQ$Chromium_cat,
                          Fluoride_Category = CA_WQ$Fluoride_cat,
                          Lead_Category = CA_WQ$Lead_cat,
                          NitrateNitrite_Category = CA_WQ$NitrateNitrite_cat,
                          Sodium_Category = CA_WQ$Sodium_cat,
                          Coliform_Total_Category = CA_WQ$TC_cat,
                          Coliform_Fecal_Category = CA_WQ$FC_cat)

Water_Quality_Cat <- cat.analysis(sites = sites_WQ, subpop = subpop_WQ, 
                                  design = dsgn_WQ, data.cat = data.cat.wq, conf=95)


# write out the results 
write.csv(Water_Quality_Cat, "2020_CA_Cat.csv")
write.csv(Water_quality_Cont$CDF, file = '2020_CA_Cont_EstCDF.csv')
write.csv(Water_quality_Cont$Pct, file = '2020_CA_Cont_EstPCT.csv')

#### 
#######################################################################################
####
######################################################################################
